{"version":3,"file":"static/preview.961b54893c6cc52396ea.bundle.js","sources":["webpack:///./src/LazyImageFull.tsx"],"sourcesContent":["import React from \"react\";\nimport Observer from \"react-intersection-observer\";\n\n/**\n * Valid props for LazyImage components\n */\nexport type CommonLazyImageProps = ImageProps & {\n  /** Whether to skip checking for viewport and always show the 'actual' component\n   * @see https://github.com/fpapado/react-lazy-images/#eager-loading--server-side-rendering-ssr\n   */\n  loadEagerly?: boolean;\n\n  /** Subset of props for the IntersectionObserver\n   * @see https://github.com/thebuilder/react-intersection-observer#props\n   */\n  observerProps?: ObserverProps;\n\n  /** Use the Image Decode API;\n   * The call to a new HTML <img> elementâ€™s decode() function returns a promise, which,\n   * when fulfilled, ensures that the image can be appended to the DOM without causing\n   * a decoding delay on the next frame.\n   *  @see: https://www.chromestatus.com/feature/5637156160667648\n   */\n  experimentalDecode?: boolean;\n};\n\n/** Valid props for LazyImageFull */\nexport interface LazyImageFullProps extends CommonLazyImageProps {\n  /** Children should be either a function or a node */\n  children: (args: RenderCallbackArgs) => React.ReactNode;\n}\n\n/** Values that the render props take */\nexport interface RenderCallbackArgs {\n  imageState: ImageState;\n  imageProps: ImageProps;\n  /** When not loading eagerly, a ref to bind to the DOM element. This is needed for the intersection calculation to work. */\n  ref?: React.RefObject<any>;\n}\n\nexport interface ImageProps {\n  /** The source of the image to load */\n  src: string;\n\n  /** The source set of the image to load */\n  srcSet?: string;\n\n  /** The alt text description of the image you are loading */\n  alt?: string;\n\n  /** Sizes descriptor */\n  sizes?: string;\n}\n\n/** Subset of react-intersection-observer's props */\nexport interface ObserverProps {\n  /**\n   * Margin around the root that expands the area for intersection.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/rootMargin\n   * @default \"50px 0px\"\n   * @example Declaration same as CSS margin:\n   *  `\"10px 20px 30px 40px\"` (top, right, bottom, left).\n   */\n  rootMargin?: string;\n\n  /** Number between 0 and 1 indicating the the percentage that should be\n   * visible before triggering.\n   * @default `0.01`\n   */\n  threshold?: number;\n}\n\n/** The component's state */\nexport type LazyImageFullState = {\n  hasBeenInView: boolean;\n  imageState: ImageState;\n};\n\n/** States that the image loading can be in.\n * Used together with LazyImageFull render props\n * */\nexport enum ImageState {\n  NotAsked = \"NotAsked\",\n  Loading = \"Loading\",\n  LoadSuccess = \"LoadSuccess\",\n  LoadError = \"LoadError\"\n}\n\n/**\n * Component that preloads the image once it is in the viewport,\n * and then swaps it in. Takes a render prop that allows to specify\n * what is rendered based on the loading state.\n */\nexport class LazyImageFull extends React.Component<\n  LazyImageFullProps,\n  LazyImageFullState\n> {\n  static displayName = \"LazyImageFull\";\n\n  initialState = { hasBeenInView: false, imageState: ImageState.NotAsked };\n\n  constructor(props: LazyImageFullProps) {\n    super(props);\n    this.state = this.initialState;\n\n    // Bind methods\n    // This would be nicer with arrow functions and class properties,\n    // but holding off until they are settled.\n    this.onInView = this.onInView.bind(this);\n    this.onLoadSuccess = this.onLoadSuccess.bind(this);\n    this.onLoadError = this.onLoadError.bind(this);\n  }\n\n  // Update functions\n  onInView(inView: boolean) {\n    if (inView === true) {\n      // If src is not specified, then there is nothing to preload; skip to Loaded state\n      if (!this.props.src) {\n        this.setState((state, _props) => ({\n          ...state,\n          imageState: ImageState.LoadSuccess\n        }));\n      } else {\n        // Kick off request for Image and attach listeners for response\n        this.setState((state, _props) => ({\n          ...state,\n          imageState: ImageState.Loading\n        }));\n\n        loadImage(\n          {\n            src: this.props.src,\n            srcSet: this.props.srcSet,\n            alt: this.props.alt,\n            sizes: this.props.sizes\n          },\n          this.props.experimentalDecode\n        )\n          .then(this.onLoadSuccess)\n          .catch(this.onLoadError);\n      }\n    }\n  }\n\n  onLoadSuccess() {\n    this.setState((state, _props) => ({\n      ...state,\n      imageState: ImageState.LoadSuccess\n    }));\n  }\n\n  onLoadError() {\n    this.setState((state, _props) => ({\n      ...state,\n      imageState: ImageState.LoadError\n    }));\n  }\n\n  // Render function\n  render() {\n    const {\n      children,\n      loadEagerly,\n      observerProps,\n      experimentalDecode,\n      ...imageProps\n    } = this.props;\n\n    if (loadEagerly) {\n      // If eager, skip the observer and view changing stuff; resolve the imageState as loaded.\n      return children({ imageState: ImageState.LoadSuccess, imageProps });\n    } else {\n      return (\n        <Observer\n          rootMargin=\"50px 0px\"\n          threshold={0.01}\n          {...observerProps}\n          onChange={this.onInView}\n          triggerOnce\n        >\n          {({ ref }) =>\n            children({ imageState: this.state.imageState, imageProps, ref })\n          }\n        </Observer>\n      );\n    }\n  }\n}\n\n// Utilities\n\n/** Promise constructor for loading an image */\nconst loadImage = (\n  { src, srcSet, alt, sizes }: ImageProps,\n  experimentalDecode = false\n) =>\n  new Promise((resolve, reject) => {\n    const image = new Image();\n    if (srcSet) {\n      image.srcset = srcSet;\n    }\n    if (alt) {\n      image.alt = alt;\n    }\n    if (sizes) {\n      image.sizes = sizes;\n    }\n    image.src = src;\n\n    /** @see: https://www.chromestatus.com/feature/5637156160667648 */\n    if (experimentalDecode && \"decode\" in image) {\n      image\n        // NOTE: .decode() is not in the TS defs yet\n        //@ts-ignore\n        .decode()\n        .then(() => resolve())\n        .catch((err: any) => reject(err));\n      return;\n    }\n\n    image.onload = resolve;\n    image.onerror = reject;\n  });\n"],"mappings":"AAiFA","sourceRoot":""}